using Base: String, Bool, Complex
# using Core: Matrix, Vector
using LinearAlgebra
using Random 
using ProgressMeter

include("CHform.jl")
include("GSmat.jl")

mutable struct VarMH
    HPm::HPmat #matrices H and P, coefficient
    E::Float64 #energy
    Anglelist::Array{Int8} #Array (3 dimensional) storing the all angles (for all stabilizers and layers, lines = layers ; columns = stabilizers states; 3rd dimension = Angles)
    L::Int8 #number of layers
    #Constructor
    VarMH(N,R,L, J, h) = new(HPmat(N, R, J, h), 0. , zeros(Int8, L, R, 2*N), L::Int8)
end

#=TODO: - regarder si un algo de résolution de problème aux valeurs propres généralisé est dispo en julia ou si c'est vite codé
        - OU regarder si insérer du python dans du julia est possible=#
#------------------INITIALIZTATION -------------------------------------------------
function initVMHtoHF(Vmh::VarMH, recursion::Int8 = Int8(0))
    # first we set the 
    for k::Int8 in 1:Vmh.HPm.CHlist[1].N #we only change the last layer of the variational circuit to generate the HF state
        # Vmh.Anglelist[Vmh.L, 1::Int8, Int8(2*k-1)] = 6::Int8 #Rx(6*pi/2) = iX #first stabilizer --> *1 for the # of the stabilizer
        Vmh.Anglelist[Vmh.L, 1, Int8(2*k-1)] = Int8(0) #Rx(6*pi/2) = iX #first stabilizer --> *1 for the # of the stabilizer
        Vmh.Anglelist[Vmh.L, 1, Int8(2*k)] = Int8(0) #Rz(6*pi/2) = iZ
        #Note that iZiX|0> = -ZX|0> =|1>
    end
    #updating the CH-form list with the HF state
    # println("stab = init ",Vmh.HPm.P)
    VarCirc = genVarCirc(Vmh, Vmh.L, 1)
    updateHP(Vmh.HPm, 1, VarCirc,1)
    # println("stab = 1 ",Vmh.HPm.P)
    # println("=================")
    #generating other HF + small excitation states (the small excitations are generated by changing the angles on Rz gates)
    for r::Int64 in 2:Vmh.HPm.R
        tmpHP = genRandHFstab(Vmh, r)
        maxTry = 0
        expOffset::Int8 = Int8(0)
        while (rank(tmpHP.P)<r) & (maxTry <= 2*Vmh.HPm.CHlist[1].N)
            # println("tut")
            maxTry += 1
            #retry 
            tmpHP = genRandHFstab(Vmh, r, expOffset)
            if (maxTry >= 2*Vmh.HPm.CHlist[1].N) #there is probably no indep stabilizer obtainable by changing only expOffset angles, try expOffset + 1 angles
                # println("reset")
                maxTry = 0
                expOffset += Int8(1)
            end
            # println(Vmh.Anglelist)
        end
        # println("rank = ",rank(tmpHP.P))
        #accept the change
        Vmh.HPm = deepcopy(tmpHP)
    end
    # println(rank(Vmh.HPm.P))
    # println("=================")
    # println(Vmh.HPm.P)
    #computation of the energy and the coefficients of the decomposition
    vals, vecs = eigen(Vmh.HPm.H, Vmh.HPm.P) 
    # println(vals)
    #find the minimal energy
    Vmh.E = 0.0
    # print(typeof(Vmh.E))
    Vmh.HPm.Phaselist = vecs[:,1] 
    for k in 1:length(vals)
        if (real(vals[k]) < Vmh.E) & (abs(imag(vals[k])) < 1e-14)
            Vmh.E = real(vals[k])
            Vmh.HPm.Phaselist = vecs[:, k] 
        end
    end
    #Error Handling
    #Stop if we can't find a non-NaN value for E
    if recursion >= 10
        throw(DomainError(recursion,"Cannot find an initial state without NaN energy"))
    end
    #If the value is NaN, try again until recursion is too high
    if isnan(Vmh.E)
        initVMHtoHF(Vmh, recursion + 1)
    end
    #normalize the coefficients in the decomposition
    # nrm = sqrt(dot(Vmh.HPm.Phaselist, conj(Vmh.HPm.Phaselist)))
    nrm = norm(Vmh.HPm.Phaselist) #default norm for the norm function: Euclidean
    Vmh.HPm.Phaselist = Vmh.HPm.Phaselist/nrm
end

function genRandHFstab(Vmh::VarMH, r::Int64, expOffset::Int8 = Int8(0))
    # r is the index of the current stabilizer
    tmpHP = deepcopy(Vmh.HPm)
    n = Int64(Vmh.HPm.CHlist[1].N)
    #computing the amount angles to be changed
    count::Int64 = n
    expnt::Int8 = Int8(1 + expOffset)
    while (r > count)
        expnt += Int8(1)
        count += n ^expnt
        if expnt >= 2*n
            throw(DomainError(expnt,"Too many stabilizers"))
        end
    end
    #changing the required amount of angles to generate a new state
    usedExp::Vector{Int8} = []
    for c in 1:expnt
        #trying some qubit
        idx = Int8(rand(1:2*Vmh.HPm.CHlist[1].N))
        while idx in usedExp #checking the qubit has not already been affected
            idx = Int8(rand(1:2*Vmh.HPm.CHlist[1].N))
        end
        append!(usedExp, [idx])
        #choosing randomly a new angle
        nwangl = Int8(rand(1:8))
        Vmh.Anglelist[Vmh.L, r, idx] = nwangl
    end
    #constructing the variational circuit
    varCirc = genVarCirc(Vmh, Vmh.L, r)
    #applying the change
    updateHP(tmpHP, r, varCirc, r)
    return tmpHP
end

# -----------------RUN -------------------------------------------------------------
# function run(Vmh::VarMH, Nsteps::UInt64, Tin::Float64, Tfin::Float64::String = "cliff", boolHomogeneous::Bool = false)
function run(Vmh::VarMH, Nsteps::UInt64, Tin::Float64, Tfin::Float64)
    #Computing the temperature curve
    x = LinRange(2., 10., Nsteps)
    T = ( Tin .+ (Tfin - Tin)*(log.(x) .-log(2))/(log(10)-log(2)))
    #initialising useful data
    Elog::Vector{Float64} = [] #logs the energy
    offset::Int64 = 0 #used in the restart procedure
    Tlog::Vector{Float64} = [] #logs the temperature (for debugging)
    #Computing beta
    Btemp::Vector{Float64} = 1. ./T
    # Computing the analytical energy to check that the result is not abhorrent
    m = 1:Vmh.HPm.CHlist[1].N
    m = m .- floor(Vmh.HPm.CHlist[1].N/2) #element-wise substraction
    #computation of k
    k = 2*pi .*m ./Vmh.HPm.CHlist[1].N
    #Method 1
    # #construction of lambda
    # lda = -Vmh.HPm.h ./Vmh.HPm.J
    # # lda = 1/lda/4
    # #big lambda_k
    # LdaK = sqrt.(1 .+ lda^2 .+ 2*lda .*cos.(k))
    # #ground state energy
    # E0 = -sum(LdaK)
    #Method 2
    E0 = -1 * sum(sqrt.((-Vmh.HPm.h/Vmh.HPm.J .- cos.(k)).^2 + sin.(k).^2))
    @showprogress for k in 1:Nsteps #TODO - mettre la barre de progression
        # HPtmp = deepcopy(Vmh.HPm)
        # Etmp = deepcopy(Vmh.E)
        append!(Tlog, [T[k-offset]])
        #do a step 
        step(Vmh, Btemp[k-offset])
        # #redo the step if it failed to change the approximation (and if we are in the homogeneous case)
        # while Vmh.HPm.areEqualHP(HPtmp) and boolHomogeneous
        # # while abs(Vmh.E - Etmp) < 1e-10 and boolHomogeneous:
        #     # print('try', k, Vmh.E)
        #     Vmh.step(Btemp[k-offset])
        # end
        # #log the energy for reference
        # append!(Elog, [Vmh.E])
        if Vmh.E < E0
            println(Vmh.Anglelist)
            println(E0)
            break
        else
            append!(Elog, [Vmh.E])
        end
        #restart 
        if Elog[k-offset] - Vmh.E < 1e-14#we only restart if we have found a new state
            # print('accept', k, Vmh.E)
            maxProba = max(200, Nsteps/100)
            # r = random.randint(0, maxProba)
            r = Int64(rand(1:maxProba))
            if r == 1 #restart is accepted
                # println('=================================RESTART========================================')
                offset = k
                x = LinRange(2., 10., Nsteps-k)
                T = ( Tin .+ (Tfin - Tin)*(log.(x) .-log(2))/(log(10)-log(2)))
                Btemp = 1. ./T
            end
        end
        # if Elog[k] < E0 
        #     println(Vmh.Anglelist)
        #     println(E0)
        #     break
        # end
        #checking if the energy is indeed a number
        if isnan(Elog[k])
            throw(DomainError(Elog[k],"Energy is NaN"))
        end
        return Elog, Tlog
    end
end

function step(Vmh::VarMH, Beta::Float64)
    tmpVMH = deepcopy(Vmh)
    sampleStab(tmpVMH)
    #TODO - reprendre depuis ici
    iterat = 0 #failsafe in case we cannot modify the matrices and still have them full rank
    while (rank(tmpVMH.HPm.P)<Vmh.HPm.R) & (iterat < 100*Vmh.HPm.R) #checking that P is full rank, if not we try another step (no need to have H full rank)
        tmpVMH = deepcopy(Vmh)
        sampleStab(tmpVMH)
        # iterat += 1
        print(rank(tmpVMH.HPm.P), " ")
    end
    if rank(tmpVMH.HPm.P)<Vmh.HPm.R
        print(iterat, " ")
        print(rank(tmpVMH.HPm.P), " ")
        println("Not full rank")
    end
    if iterat > 100*Vmh.HPm.R-1 #no modification of the stab. decomposition keeps the full rank of the matrices 
        println("Not full rank")
        throw(DomainError(iterat,"Cannot find a new element for the stabilizer decomposition"))
    else
        #sucessful modification
        # E, alphas = eigh(tmp.H, tmp.P, eigvals_only=False) #compute the energy and the coefficients of the decomposition
        E, alphas = eigen(tmpVMH.HPm.H, tmpVMH.HPm.P) #compute the energy and the coefficients of the decomposition
        tmpE = 0.0
        tmpPhaselist = alphas[:,1] 
        for k in 1:length(E)
            if (real(E[k]) <real(tmpE)) & (abs(imag(E[k])) < 1e-14) & (~isnan(E[k]))
                tmpE = real(E[k])
                tmpPhaselist = alphas[:,k] 
            end
        end
        if tmpE <= Vmh.E
            Vmh.HPm = tmpVMH.HPm
            Vmh.E = tmpE
            nrm = norm(tmpPhaselist)
            Vmh.HPm.Phaselist = tmpPhaselist/nrm
            Vmh.Anglelist = tmpVMH.Anglelist 
        else
            b = rand(Float64) #random number in [0,1)
            if b < exp(-Beta*(tmpE-Vmh.E)) #avoids accepting too large steps in the wrong direction
                Vmh.HPm = tmpVMH.HPm
                Vmh.E = tmpE
                nrm = norm(tmpPhaselist)
                Vmh.HPm.Phaselist = tmpPhaselist/nrm
                Vmh.Anglelist = tmpVMH.Anglelist
                #else we keep the same distribution as before
            end
        end
    end
end

function sampleStab(Vmh::VarMH)
    rdLyr::Int8 = Int8(rand(1:Vmh.L)) #which layer to modify
    rdStb::Int64 = Int8(rand(1:Vmh.HPm.R)) #which stabilizer state
    rdQb::Int8 = Int8(rand(1:Vmh.HPm.CHlist[1].N)) #which qubit
    rdAgl1::Int8 = Int8(rand(0:7)) #which angle for the first rotatition gate
    rdAgl2::Int8 = Int8(rand(0:7)) #which angle for the second rotatition gate
    # print(randIdx)
    #select types of gates
    # tmpVMH = deepcopy(Vmh)
    #change the angles
    Vmh.Anglelist[rdLyr, rdStb, 2*rdQb-1] = rdAgl1
    Vmh.Anglelist[rdLyr, rdStb, 2*rdQb] = rdAgl2
    #update the matrices H and P
    clearElem(Vmh.HPm, [rdStb]::Vector{Int64}) #resetting the CH-form but not the angles
    for l::Int8 in 1:Vmh.L
        circ = genVarCirc(Vmh, l, rdStb)
        updateHP(Vmh.HPm, rdStb, circ)
    end
end

# -----------------RUN but in the com. basis -------------------------------------------------------------

function sampleCompBasis(Vmh::VarMH)
    rdLyr::Int8 = Int8(rand(1:Vmh.L)) #which layer to modify
    rdStb::Int64 = Int8(rand(1:Vmh.HPm.R)) #which stabilizer state
    rdQb::Int8 = Int8(rand(1:Vmh.HPm.CHlist[1].N)) #which qubit
    # rdAgl1::Int8 = Int8(rand([0,6])) #which angle for the first rotatition gate (either Id or iX)
    # rdAgl2::Int8 = Int8(rand(0:7)) #which angle for the second rotatition gate
    rdAgl1 = 0 #Id
    rdAgl2 = 0 #Id
    if Vmh.Anglelist[rdLyr, rdStb, 2*rdQb-1] == 0 #if the qubit is 0 we flip it to 1
        rdAgl1 = 6 # iX
        rdAgl2 = 6 # iZ
    end
    # print(randIdx)
    #select types of gates
    # tmpVMH = deepcopy(Vmh)
    #change the angles
    Vmh.Anglelist[rdLyr, rdStb, 2*rdQb-1] = rdAgl1
    Vmh.Anglelist[rdLyr, rdStb, 2*rdQb] = rdAgl2
    #update the matrices H and P
    clearElem(Vmh.HPm, [rdStb]::Vector{Int64}) #resetting the CH-form but not the angles
    for l::Int8 in 1:Vmh.L
        circ = genCompBasisCirc(Vmh, l, rdStb)
        updateHP(Vmh.HPm, rdStb, circ)
    end
end

function stepCompBasis(Vmh::VarMH, Beta::Float64)
    tmpVMH = deepcopy(Vmh)
    sampleCompBasis(tmpVMH)
    #TODO - reprendre depuis ici
    iterat = 0 #failsafe in case we cannot modify the matrices and still have them full rank
    while (rank(tmpVMH.HPm.P)<Vmh.HPm.R) & (iterat < 100*Vmh.HPm.R) #checking that P is full rank, if not we try another step (no need to have H full rank)
        tmpVMH = deepcopy(Vmh)
        sampleCompBasis(tmpVMH)
        # iterat += 1
        print(rank(tmpVMH.HPm.P), " ")
    end
    if rank(tmpVMH.HPm.P)<Vmh.HPm.R
        print(iterat, " ")
        print(rank(tmpVMH.HPm.P), " ")
        println("Not full rank")
    end
    if iterat > 100*Vmh.HPm.R-1 #no modification of the stab. decomposition keeps the full rank of the matrices 
        println("Not full rank")
        throw(DomainError(iterat,"Cannot find a new element for the stabilizer decomposition"))
    else
        #sucessful modification
        # E, alphas = eigh(tmp.H, tmp.P, eigvals_only=False) #compute the energy and the coefficients of the decomposition
        E, alphas = eigen(tmpVMH.HPm.H, tmpVMH.HPm.P) #compute the energy and the coefficients of the decomposition
        tmpE = 0.0
        tmpPhaselist = alphas[:,1] 
        for k in 1:length(E)
            if (real(E[k]) <real(tmpE)) & (abs(imag(E[k])) < 1e-14) & (~isnan(E[k]))
                tmpE = real(E[k])
                tmpPhaselist = alphas[:,k] 
            end
        end
        if tmpE <= Vmh.E
            Vmh.HPm = tmpVMH.HPm
            Vmh.E = tmpE
            nrm = norm(tmpPhaselist)
            Vmh.HPm.Phaselist = tmpPhaselist/nrm
            Vmh.Anglelist = tmpVMH.Anglelist 
        else
            b = rand(Float64) #random number in [0,1)
            if b < exp(-Beta*(tmpE-Vmh.E)) #avoids accepting too large steps in the wrong direction
                Vmh.HPm = tmpVMH.HPm
                Vmh.E = tmpE
                nrm = norm(tmpPhaselist)
                Vmh.HPm.Phaselist = tmpPhaselist/nrm
                Vmh.Anglelist = tmpVMH.Anglelist
                #else we keep the same distribution as before
            end
        end
    end
end
#----------------- UTILITY FUNCTIONS ---------------------------------------------
function genVarCirc(Vmh::VarMH, layer::Int8, stabIdx::Int64) #Generates a variational quantum circuit similar to one used in VQE, using angles found in Vmh
    circ::Vector{Vector{String}} = [[],[]]
    for k::Int8 in 1:Vmh.HPm.CHlist[1].N
        #rotation gates %TODO
        # rxcirc = RxGate(Vmh.Anglelist[2*Vmh.HPm.CHlist[1].N*(Vmh.R*layer + stabIdx)+k], k)
        rxcirc = RxGate(Vmh.Anglelist[layer,stabIdx, 2*k-1], k)
        rzcirc = RzGate(Vmh.Anglelist[layer,stabIdx, 2*k], k)
        append!(circ[1], append!(rxcirc[1], rzcirc[1]))
        append!(circ[2], append!(rxcirc[2], rzcirc[2]))
    end
    for k::Int8 in 1:Vmh.HPm.CHlist[1].N
        #CNOT gates
        append!(circ[1], ["CX"])
        append!(circ[2], [string(string(k), " ", string(mod(k,Vmh.HPm.CHlist[1].N)+1))])
    end
    # print(circ)
    return circ
end

function genCompBasisCirc(Vmh::VarMH, layer::Int8, stabIdx::Int64) # same as genVarCirc but without the CNOTs to only have comp. basis states
    circ::Vector{Vector{String}} = [[],[]]
    for k::Int8 in 1:Vmh.HPm.CHlist[1].N
        #rotation gates %TODO
        # rxcirc = RxGate(Vmh.Anglelist[2*Vmh.HPm.CHlist[1].N*(Vmh.R*layer + stabIdx)+k], k)
        rxcirc = RxGate(Vmh.Anglelist[layer,stabIdx, 2*k-1], k)
        rzcirc = RzGate(Vmh.Anglelist[layer,stabIdx, 2*k], k)
        append!(circ[1], append!(rxcirc[1], rzcirc[1]))
        append!(circ[2], append!(rxcirc[2], rzcirc[2]))
    end
    return circ
end 

function RzGate(exponent::Int8, qb::Int8) #Translate Z rotation gates of k*pi/4 into product of Cliffords
    circ::Vector{Vector{String}} = [[],[]]
    expbit = digits(exponent, base = 2, pad = 3)
    append!(circ[1],["Id"])
    append!(circ[2],[string(((1-1im)/sqrt(2))^exponent)])
    if expbit[1] == 1 #S
        append!(circ[1], ["S"])
        append!(circ[2], [string(qb)])
    end
    if expbit[2] == 1 #Z
        append!(circ[1], ["Z"])
        append!(circ[2], [string(qb)])
    end
    if expbit[3] == 1 #-Id  --> minus sign for k>=4 
        append!(circ[1], ["Id"])
        append!(circ[2], [string(-1)])
    end
    return circ
end

function RxGate(exponent::Int8, qb::Int8) #Translates X rotation gates of k*pi/4 into product of Cliffords
    # exponent -= 1
    circ::Vector{Vector{String}} = [[],[]] 
    if exponent == 0
        append!(circ[1], ["Id"])
        append!(circ[2], [string(1)])
    elseif exponent == 1
        append!(circ[1], ["S","Z","H","Z","S"])
        append!(circ[2], [string(qb), string(qb), string(qb), string(qb), string(qb)])
    elseif exponent == 2
        # append!(circ[1], ["Id","H","Z","H"]
        # append!(circ[2], [string(-1im), string(qb), string(qb), string(qb)]
        append!(circ[1], ["Id","X"])
        append!(circ[2], [string(-1im), string(qb)])
    elseif exponent == 3
        append!(circ[1], ["Id","S","H","S"])
        append!(circ[2], [string(-1), string(qb), string(qb), string(qb)])
    elseif exponent == 4
        append!(circ[1], ["Id"])
        append!(circ[2], [string(-1)])
    elseif exponent == 5
        append!(circ[1], ["Id","S","Z","H","Z","S"])
        append!(circ[2], [string(-1), string(qb), string(qb), string(qb), string(qb), string(qb)])
    elseif exponent == 6
        # append!(circ[1], ["Id","H","Z","H"])
        # append!(circ[2], [string(1im), string(qb), string(qb), string(qb)])
        append!(circ[1], ["Id","X"])
        append!(circ[2], [string(1im), string(qb)])
    elseif exponent == 7 
        append!(circ[1], ["S","H","S"])
        append!(circ[2], [string(qb), string(qb), string(qb)])
    end
    return circ
end